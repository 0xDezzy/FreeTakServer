#######################################################
# 
# orchestrator.py
# Python implementation of the Class orchestrator
# Generated by Enterprise Architect
# Created on:      21-May-2020 12:24:48 PM
# Original author: Natha Paquette
# 
#######################################################
from importlib import import_module
from RecieveConnections import RecieveConnections
from ClientInformationController import ClientInformationController
from ClientReceptionHandler import ClientReceptionHandler
from ClientSendHandeler import ClientSendHandeler
from SendClientData import SendClientData
from DataQueueController import DataQueueController
from ClientInformationQueueController import ClientInformationQueueController
from ActiveThreadsController import ActiveThreadsController
from recieveConnectionsProcessController import recieveConnectionsProcessController
from MainSocketController import MainSocketController
from XMLCoTController import XMLCoTController
from SendOtherController import SendOtherController
from SendDataController import SendDataController
import multiprocessing
import threading
import time
import pickle
import importlib
from queue import Queue
import argparse

class orchestrator:
# default constructor  def __init__(self):  
    def __init__(self):
        #create necessary queues
        self.clientInformationQueue = []
        self.pipeList = []

        #instantiate controllers
        self.m_ActiveThreadsController = ActiveThreadsController()
        self.m_ClientInformationController = ClientInformationController()
        self.m_ClientInformationQueueController = ClientInformationQueueController() 
        self.m_ClientSendHandeler = ClientSendHandeler() 
        self.m_DataQueueController = DataQueueController() 
        self.m_RecieveConnections = RecieveConnections() 
        self.m_recieveConnectionsProcessController = recieveConnectionsProcessController()
        self.m_MainSocketController = MainSocketController()
        self.m_XMLCoTController = XMLCoTController()
        self.m_SendClientData = SendClientData()


    def addProcessDataToClientInformation(self,processData):
        pass

    def beginManageClients(self):
        pass

    def beginRecieveConnection(self):
        pass

    def clientConnected(self,rawConnectionInformation):
        try:
            print('establishing client connection')
            orchestratorPipe, clientPipe = multiprocessing.Pipe()
            #instantiate model
            clientInformation = self.m_ClientInformationController.intstantiateClientInformationModelFromConnection(rawConnectionInformation, clientPipe)
            #add client information to queue
            self.m_ClientInformationQueueController.addClientToQueue(clientInformation)
            self.clientInformationQueue.append(clientInformation)
            #begin client reception handler
            receptionHandler = multiprocessing.Process(target=ClientReceptionHandler().monitorForData, args=(clientInformation, clientPipe))
            receptionHandler.start()
            pipeTuple = (orchestratorPipe, clientPipe)
            self.pipeList.append(pipeTuple)
            #add to active threads
            self.m_ActiveThreadsController.addClientThread(clientInformation, receptionHandler)
            #send all client data needs to be implemented
            SendDataController().sendDataInQueue(clientInformation, clientInformation, self.clientInformationQueue)
            print('finnished establishing client connection')
        except Exception as e:
            print('exception in controller, clientConnected')
            print(e)

    def dataRecieved(self,RawCoT):
        # this will be executed in the event that the use case for the CoT isnt specified in the orchestrator
        try:
            #this will check if the CoT is applicable to any specific controllers            
            RawCoT = self.m_XMLCoTController.determineCoTType(RawCoT)
            #the following calls whatever controller was specified by the above function
            module = importlib.import_module(RawCoT.CoTType)
            CoTSerializer = getattr(module, RawCoT.CoTType)
            processedCoT = CoTSerializer().instantiateDomainModel(RawCoT)
            sender = processedCoT.clientInformation
            #this will send the processed object to a function which will send it to connected clients
            SendDataController().sendDataInQueue(sender, processedCoT, self.clientInformationQueue)
        except:
            print('error in dataRecieved')
    def clientDisconnected(self, clientInformation):
        #print(self.clientInformationQueue[0])
        #print(clientInformation)
        for client in self.clientInformationQueue:
            if client.ID == clientInformation.clientInformation.ID:
                self.clientInformationQueue.remove(client)
            else:
                pass
        self.m_ActiveThreadsController.removeClientThread(clientInformation)

    def monitorRawCoT(self):
        print('monitoring begins')
        from model.RawCoT import RawCoT
        while True:
            try:
                if len(self.pipeList)>0:
                    for pipeTuple in self.pipeList:
                        #this while loop runs on each pipe to extract all data within
                        while pipeTuple[0].poll():
                            try:
                                data = pipeTuple[0].recv()
                                print('data recieved')
                                #this will attempt to define the type of CoT along with the designated controller
                                CoT = XMLCoTController().determineCoTGeneral(data)
                                function = getattr(self, CoT[0])
                                function(CoT[1])
                                #this checks wether or not the data is a new connection
                                #            
                            except:
                                print('minor monitor Raw CoT error')
                                pass
                else:
                    pass
            except:
                print('error in monitor Raw cot')
                pass

    def killClientHandelerThread(self,clientInformation):
        pass

    def start(self, IP, port):
        #create socket controller
        self.m_MainSocketController.changeIP(IP)
        self.m_MainSocketController.changePort(port)
        sock = self.m_MainSocketController.createSocket()

        #create pipe for reception of connections
        orchestratorPipe, recieveConnectionPipe = multiprocessing.Pipe()
        pipeTuple = (orchestratorPipe, recieveConnectionPipe)
        self.pipeList.append(pipeTuple)
        
        #begin to monitor all pipes
        monitorRawCoTProcess = multiprocessing.Process(target = self.monitorRawCoT, args = ())
        monitorRawCoTProcess.start()

        time.sleep(3)

        #begin DataPackageServer


        time.sleep(3)
        #begin to recieve connections
        recieveConnectionProcess = multiprocessing.Process(target=self.m_RecieveConnections.listen, args=(sock,recieveConnectionPipe,))
        recieveConnectionProcess.start()

        #instantiate domain model and save process as object
        activeRecieveConnectionProcess = self.m_recieveConnectionsProcessController.InstantiateModel(recieveConnectionProcess)
        print('server has started')
        while True:
            time.sleep(1000)

    def stop(self):
        pass
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='FreeTAKServer startup settings')
    parser.add_argument('-CoTPort', type = int, help = 'the port you would like FreeTAKServer to run receive connections on', default=8087)
    parser.add_argument('-CoTIP', type = str, help = "the IP you would like FreeTAKServer to run receive connections on ONLY CHANGE IF YOU KNOW WHAT YOU'RE DOING", default='0.0.0.0')
    parser.add_argument('-DataIP', type = str, help = 'the ip address you would like FreeTAKServer to run receive datapackages on this is necesarry if its not set correctly data packages will fail',)
    parser.add_argument('-DataPort', type = int, help = 'the port address you would like FreeTAKServer to run receive datapackages on not', default=8080)
    args = parser.parse_args()
    orchestrator().start(args.CoTIP, args.CoTPort)

