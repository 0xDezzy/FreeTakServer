#######################################################
# 
# ClientReceptionHandler.py
# Python implementation of the Class ClientReceptionHandler
# Generated by Enterprise Architect
# Created on:      19-May-2020 7:17:21 PM
# Original author: Natha Paquette
# 
#######################################################
import time
from xml.dom.minidom import parseString
#TODO: add more rigid exception management
class ClientReceptionHandler:
# default constructor  def __init__(self):  
    #changed client, address to 
    
    def monitorForData(self, clientInformation, pipe):
        '''
        updated receive all 
        '''
        print('client handeler started')
        try:
            try:                
                BUFF_SIZE = 8087
                client = clientInformation.socket
                data = b''
            except Exception as e:
                print('monitor error 3')
                self.returnRecievedData(clientInformation, b'', pipe)
                print(e)
            while True:
                try:
                    part = client.recv(BUFF_SIZE)
                    if part == b'' or part == None:
                        self.returnRecievedData(clientInformation, b'', pipe)
                        break
                    elif len(part) < BUFF_SIZE:
                        # either 0 or end of data
                        data += part 
                        self.returnRecievedData(clientInformation, data, pipe)
                        data = b''
                    else:
                        data += part
                except Exception as e:
                    print(part)
                    print('monitor error 2')
                    self.returnRecievedData(clientInformation, b'', pipe)
                    print(e)
                    break
        except Exception as e:
            print('monitor error 1')
            self.returnRecievedData(clientInformation, b'', pipe)
            print(e)

    def returnRecievedData(self, clientInformation, data, pipe):
        try:
            from model.RawCoT import RawCoT
            RawCoT = RawCoT()
            #print(data)
            RawCoT.clientInformation = clientInformation
            RawCoT.xmlString = data
            pipe.send(RawCoT)

        except Exception as e:
            print('return error')
            print(e)
    def recieveAll(self, client):
        """this needs to be updated and possibly integrated with monitorForData.
        """
        '''
        try:
            total_data = []
            count = 0
            dead = 0
            final = []
            #227:260
            #360:393
            while True:
                data = client.recv(const.BUFFER)
                print(sys.getsizeof(data))
                if sys.getsizeof(data)==const.BUFFER+33:
                    total_data.append(data)
                elif sys.getsizeof(data) < const.BUFFER+33:
                    total_data.append(data)
                    break
            total_data=b''.join(total_data)
            return total_data
        except Exception as e:
            logger.warning('error in recieve all')
            logger.warning(e)
            return None
        '''
        pass

    def listenToClient(self, client, address):
        pass
        '''
        """Function to receive data from the client. though should be used as refrence as
        it will be rendered obsolete with the implementation of monitorForData
        """
        try:
            defaults = self.connectionSetup(client, address)
            if defaults == 'error':
                client.shutdown()
                client.close()
                return 1
            elif defaults == 'Bandaid':
                client.close()
                return 1
            else:
                defaults = defaults.split(' ? ')
                print(defaults)
                first_run=defaults[0]
                id_data=defaults[2]
                current_id = defaults[3]
                first_run = int(first_run)
                id_data = bytes(id_data, 'utf-8')
                current_id = int(current_id)
                #main connection loop
                killSwitch = 0
                while killSwitch == 0:
                    #recieve data

                    try:
                        if first_run == 0:
                            data = self.recieveAll(client)
                            logger.debug(data)
                            working = self.check_xml(data, current_id)
                            #checking if check_xml detected client disconnect
                            if working == const.FAIL:
                                timeoutInfo = Serializer().serializerRoot(RequestCOTController().timeout(eventhow = 'h-g-i-g-o', eventuid = uuid.uuid1(), linkuid = self.client_dict[current_id]['uid']))
                                print(timeoutInfo.encode())
                                logger.debug('sending timeout information')
                                if len(self.client_dict)>0:

                                    for x in self.client_dict:
                        
                                        if x != current_id:
                                            self.client_dict[x]['client'].send(timeoutInfo.encode())

                                        else:
                                            pass
                                else:
                                    pass
                                uid = self.client_dict[current_id]['uid']
                                del self.client_dict[current_id]
                                sqliteServer = sqlite3.connect(const.DATABASE)
                                cursor = sqliteServer.cursor()
                                cursor.execute(sql.DELETEBYUID,(uid,))
                                sqliteServer.commit()
                                cursor.close()
                                sqliteServer.close()
                                client.shutdown()
                                client.close()
                                break
                            elif working == const.PING:
                                logger.debug('recieved ping')

                            else:
                                pass
                
                        elif first_run == 1:
                            print('something \n')
                            for x in self.client_dict:
                                client = self.client_dict[x]['client']
                                if client != self.client_dict[current_id]['client']:
                                    print('sending'+str(id_data))
                                    print(id_data)
                                    client.send(self.client_dict[current_id]['id_data'])
                                else:
                                    pass
                            for x in self.client_dict:
                                data = self.client_dict[x]['id_data']
                                logger.debug('sending conn data '+str(self.client_dict[x]['id_data'])+'to '+str(client)+'\n')
                                client.send(data)
                            threading.Thread(target = self.sendClientData, args = (client, address, current_id), daemon=True).start()

                        #just some debug stuff
                        first_run = 0
                    except Exception as e:
                        logger.warning('error in main loop')
                        logger.warning(str(e))
                        client.shutdown()
                        client.close()
                        killSwitch =1
                        return 1
        except Exception as e:
            client.shutdown()
            client.close()
            return 1
        '''